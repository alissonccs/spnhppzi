rnd_ef <- rgamma(N, shape = aGamma, scale = 1 / aGamma)}
else { # lognormal  -- E(Z)=1
mu <- log(1 / sqrt(par.z + 1))
sigma <- sqrt(log(par.z + 1))
rnd_ef <- exp(rnorm(N, mean = mu, sd = sigma))
}
}
}
else{ #Entra com parâmetros para \omega. {Y_i(t) * \lambda_0(t)*exp(\beta^t X_i+\omega_i)}
rnd_ef <- rnorm(N, mean = mu.omega, sd = sigma.omega)
}
return(rnd_ef)
}
# Efeito espacial
gen_sp_rnd_ef<-function(SP_N, sp_tau, sp_alpha, nb_mat){
D<-diag(rowSums(nb_mat))
SIGMA<-sp_tau*(D-sp_alpha*nb_mat)
rnd_ef <- mvrnorm(n = 1, mu =rep(0,SP_N), Sigma = solve(SIGMA))
print(paste("rnd_ef: ", rnd_ef))
return(rnd_ef)
}
icar_sp_rnd_ef <- function(nb_mat,sig=1){
print("ICAR")
num <- rowSums(nb_mat)
n <- ncol(nb_mat)
Q <- -nb_mat
diag(Q) <- num
Q_aux=eigen(Q)$vectors[,order(eigen(Q)$values)]
D_aux=sort(eigen(Q)$values)
rnd_ef <- rnorm(n-1,0,sqrt(sig*(1/D_aux[-1])))
rnd_ef <- Q_aux%*%c(0,rnd_ef)
return(as.vector(rnd_ef))
}
if(random.ef==0){
rnd_ef<-rep(1,N)
tp_rnd_ef<-0
}else if(spatial==0){
rnd_ef<- gen_rnd_ef(N, ID, dist.z, tp_rnd_ef, par.z,mu.omega,sigma.omega)
}else{
tp_rnd_ef<-1
# rnd_ef<-gen_sp_rnd_ef(SP_N=SP_N, sp_tau=sp_tau,sp_alpha=sp_alpha, nb_mat=nb_mat)
rnd_ef<-icar_sp_rnd_ef(nb_mat,sig=1)
rnd_ef<-as.data.frame(cbind(as.numeric(row.names(nb_mat)),rnd_ef))
colnames(rnd_ef)<-c("SP_ID","rnd_ef")
rnd_ef<-ID_SP_ID %>%
left_join(rnd_ef,by="SP_ID")
rnd_ef<-rnd_ef$rnd_ef
}
print(head(rnd_ef))
print(length(rnd_ef))
#set.seed(NULL)
if(spatial==0){
rnd_ef1<-as.data.frame(cbind(ID,rnd_ef))
if(tp_rnd_ef==0){colnames(rnd_ef1)<-c("ID","z")}
else{colnames(rnd_ef1)<-c("ID","w")}
} else{
rnd_ef1<-as.data.frame(cbind(ID,SP_ID,rnd_ef))
colnames(rnd_ef1)<-c("ID","SP_ID","w")}
print(head(rnd_ef1))
print(dim(rnd_ef1))
## Define indivíduos recorrentes (INFLAÇÃO DE ZEROS)  ====
gen_zi<-function(ID,N,pi){
recurr <- t(rbinom(N, 1, pi))
}
#set.seed(234)
# recurr<-gen_zi(ID,N,pi)
# pi<-0
recurr<-gen_zi(ID,N,pi)
# set.seed(NULL)
recurr1<-as.data.frame(t(rbind(ID,recurr)))
colnames(recurr1)<-c("ID","recurr")
# if(logist==1){
#  pi<-1/(1+exp(-(1+x %*% beta.x)))
# }
## gen_data - Gera tempos de ocorrência dos eventos  ====
gen_data<-function(ID,
N,
dist.rec,
par.rec,
fu,
x,
rnd_ef){
if (dist.rec == "weibull") { # weibull
alpha1 <- par.rec[1]
alpha2 <- par.rec[2]
}
## Cálculo de alpha1_este e exp_eta ====
# Considera a forma utilizada para introdução de efeitos aleatórios
if(nr.cov==0){exp_eta=rep(1,N)}
else if(tp_rnd_ef==0){#{Y_i(t) * \lambda_0(t)* Z_i *exp(\beta^t X_i)}
exp_eta <- exp(x %*% beta.x) * rnd_ef
}else{#{Y_i(t) * \lambda_0(t)*exp(\beta^t X_i+\omega_i)}
exp_eta <- exp(x %*% beta.x + rnd_ef)
}
alpha1_eta <- alpha1*exp_eta
print(paste("alpha1_eta: ", dim(alpha1_eta)))
print(paste("exp_eta: ", dim(exp_eta)))
print(paste("N: ", N))
#print(alpha2)
## Definição dos tempos de ocorrência dos primeiros eventos ====
T<-NULL
T1<-NULL
print(paste("T: ", dim(T)))
print(paste("T1: ", dim(T1)))
# IND<-NULL
for (i in 1:N) {
t<-NULL
#print(t)
U <- runif(1)
if (dist.rec == "weibull") {
t <- ((-1)*log(U)*(alpha1_eta[i])^(-1))^(1 / alpha2) # (veja artigo Generating survival times to simulate pag 1717 tabela II)
#ind<-0
# print(i)
# print(t)
# print(fu[i])
if (t>fu[i]){
t<-fu[i]
# ind<-1
}
}
T1 <- cbind(ID[i],t)
## Definição dos tempos de ocorrência dos eventos subsequentes ====
if (recurr[i]==0 & t<fu[i]){
# print(ID[i])
# print(recurr[i])
while (t < fu[i]) {
U <- runif(1)
t1 <- t
if (dist.rec == "weibull") { # weibull
t <- ((-1)*log(U)*(alpha1_eta[i])^(-1) + (t1)^(alpha2))^(1 / alpha2)
}
#print(t)
if (t >= fu[i]) break
T1 <- rbind(T1,c(ID[i],t))
# print(T1)
}
}
T<-as.data.frame(rbind(T,T1))
# print(T)
}
colnames(T)<-c("ID","time")
print(paste("T: ", dim(T)))
## Consolida tabela contendo os dados de saída ====
tab <-T %>%
group_by(ID)%>%
mutate(#individuo = group_indices(),
ngroup=n(),
rep=row_number(),
expand=case_when((ngroup==rep & !(rep==1&(time==0 | time==fu.max)))~2,TRUE~1),
expand1=expand)%>%
expandRows("expand") %>%
mutate(ngroup1=n(),
IndRec=case_when(ngroup1>2~1, TRUE~0),
rep1=row_number(),
begin=case_when(rep1==1~0,TRUE~lag(time)),
end=case_when(ngroup1==rep1~fu.max, TRUE~time),
status=case_when(end==fu.max~0,TRUE~1)) %>%
ungroup() %>%
left_join(x1,by="ID") %>%
left_join(rnd_ef1,by="ID") %>%
left_join(recurr1,by="ID") %>%
dplyr::select(-c(time,ngroup))
return(tab)
#set.seed(NULL)
}
tab <-gen_data(ID, N, dist.rec, par.rec, fu, x,rnd_ef)
return(tab)
}
#' @param status: evento ou censura
#' @param stop: tempo até ocorrência do evento
#' @param IndRec: Indicador se o indivíduo apresenta uma ou mais recorrência
#' @param covar: Covariável
#' @param initial: Valores de incialização dos parâmetros
#' @param approach: abordagem a ser considerada (0 - frequentista, 1 - bayesiana)
#' @param frag:  uso de fragilidade (0 - sem fragilidade, 1 - com fragilidade)
#@tpfrag: tipo de fragilidade (0-rho(t) = rho0(t)*exp(X*beta + w), 1 - rho(t) = rho0(t)*Z*exp(X*beta))
#' @export
######################################################################################################
spnhppzi2<-function(formula,
data,
baseline = c("plp1", "plp2"),
approach = c("mle", "bayes"),
n_iter=4000,
n_cores=1,
n_chains=4,
ZI = c("true","false"),
FR= c("true","false"),
initial,
tp_prior=0,frag=0,mu_omega=0,
sigma_omega=0,
#shp_sigma_omega=0, scl_sigma_omega=0,
shp_sigma2_z=0, scl_sigma2_z=0,
shp_alpha1=0,scl_alpha1=0,shp_alpha2=0,scl_alpha2=0,
mu_beta=0,sigma_beta=10,
mu_psi=0,sigma_psi=10,
spatial=0,
nb_mat=NULL,
shp_tau=0,
scl_tau=0,
W_n=0
){
formula <- Formula::Formula(formula)
approach <- tolower(approach)
approach <- match.arg(approach)
baseline <- tolower(baseline)
baseline <- match.arg(baseline)
ZI <- tolower(ZI)
ZI <- match.arg(ZI)
FR <- tolower(FR)
FR <- match.arg(FR)
mf <- stats::model.frame(formula=formula, data=data)
Terms <- stats::terms(mf)
resp <- stats::model.response(mf)
X <- stats::model.matrix(formula, data = mf, rhs = 1)[,-1, drop = FALSE]
Z <- stats::model.matrix(formula, data = mf, rhs = 2)[,-1, drop = FALSE]
time <- resp[,1]
event <- resp[,2]
id <- resp[,3]
SP_ID<-resp[,4]
IndRec<- resp[,5]
data1<-as.data.frame(cbind(time,event,id,IndRec,SP_ID,X)) %>%
group_by(id) %>%
summarise(across(everything(), last,.names = "max_{.col}"))
data2<-as.data.frame(cbind(time,event,id,IndRec,Z)) %>%
group_by(id) %>%
summarise(across(everything(), last,.names = "max_{.col}"))
n_ind1<-as.data.frame(cbind(event,id)) %>%
group_by(id) %>%
summarise(n_ind1=sum(event)) %>%
dplyr::select("n_ind1")
n_ind1<-as.vector(unlist(n_ind1))
# print(head(n_ind1,n=200))
# print(max(n_ind1))
position_ind<-as.data.frame(id) %>%
group_by(id) %>%
summarise(n_ind=n()) %>%
mutate(end_ind=cumsum(n_ind), begin_ind=end_ind-n_ind+1) %>%
dplyr::select(n_ind,begin_ind,end_ind)
n_ind<-as.vector(unlist(position_ind$n_ind))
begin_ind<-as.vector(unlist(position_ind$begin_ind))
end_ind<-as.vector(unlist(position_ind$end_ind))
# print(head(n_ind))
# n_ind1<-as.data.frame(id) %>%
#   group_by(id) %>%
#   summarise(n_ind1=sum(event)) %>%
#   select(n_ind1)
# n_ind1<-as.vector(unlist(n_ind1))
# print(head(n_ind1))
max_stop <- as.vector(unlist(data1[,2]))
IndRec2<- as.vector(unlist(data1[,4]))
gr_SP_ID<- as.vector(unlist(data1[,5]))
N <- length(time)
SP_N<-nrow(nb_mat)
n <- length(max_stop)
# print(length(max_stop))
p <- ncol(X)
q <- ncol(Z)
print(q)
#print(p)
#print(q)
if(p==0){
X <- array(0, dim = c(0, 0))
Xy <- array(0, dim = c(0, 0))
}else{
Xy<-as.matrix((data1[,-(1:5)] ))
}
#print(head(X))
#print(head(Xy))
if(q==0){
Z <- array(0, dim = c(0, 0))
Z1 <- array(0, dim = c(0, 0))
}else{
Z1<-as.matrix((data2[,-(1:4)] ))
}
#print(head(Z))
# print(head(Z1,n=20L))
baseline <- switch(baseline,
"plp" = 0,
"plp1" = 1
)
if(baseline == 0){
m <- 2
}
if(baseline == 1){
m <- 2
}
approach <- switch(approach,
"mle" = 0,
"bayes" = 1
)
FR <- switch(FR,
"true" = 1,
"false" = 0
)
ZI <- switch(ZI,
"true" = 1,
"false" = 0
)
data_model <- list(id=id,evento=event,time=time, X=X, Z=Z, N=N, Xy=Xy, Z1=Z1,
max_stop=max_stop, n=n, p=p, q=q, IndR=IndRec, IndRec2=IndRec2, approach=approach, FR=FR, ZI=ZI,
begin_ind=begin_ind,end_ind=end_ind,
n_ind=n_ind,n_ind1=n_ind1, m=m, mu_omega=mu_omega,shp_sigma2_z=shp_sigma2_z, scl_sigma2_z=scl_sigma2_z,
sigma_omega=sigma_omega,
shp_alpha1=shp_alpha1, scl_alpha1=scl_alpha1, shp_alpha2=shp_alpha2, scl_alpha2=scl_alpha2,mu_beta=mu_beta,
sigma_beta=sigma_beta,mu_psi=mu_psi,
sigma_psi=sigma_psi, tp_hf=baseline, tp_prior=tp_prior,
SP_ID,gr_SP_ID, SP_N, nb_mat=nb_mat, shp_tau=shp_tau, scl_tau=scl_tau, W_n=W_n
)
if(spatial==0){
if(FR==0){
if(ZI==0){
#  mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/3.6/spnhppzi/stan/NHPP_COV_4.stan")
# mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/NHPPZISP/stan/NHPP_COV_4.stan")
#mod <- rstan::stan_model("/usr/local/lib/R/site-library/NHPPZISP/stan/NHPP_COV_4.stan")
mod <- stanmodels$NHPP_COV_4
}
else{
if(q==0){
#  mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/3.6/spnhppzi/stan/NHPP_ZI_03_07_2022.stan")
#mod<- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/NHPPZISP/stan/NHPP_ZI_1_08_03_2022.stan")
#mod<- rstan::stan_model("/usr/local/lib/R/site-library/NHPPZISP/stan/NHPP_ZI_1_08_03_2022.stan")
# mod<- stanmodels$NHPP_ZI_1_08_03_2022
#mod<- rstan::stan_model("/home/alisson/R/x86_64-pc-linux-gnu-library/4.2/spnhppzi/stan/NHPP_ZI_03_07_2022.stan")
mod<- stanmodels$NHPP_ZI_03_07_2022
}
else{
# mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/3.6/spnhppzi/stan/NHPP_ZI_LOGISTCOV_09_03_2022.stan")
#
#mod<- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/NHPPZISP/stan/NHPP_ZI_LOGISTCOV_09_03_2022.stan")
#mod<- rstan::stan_model("/usr/local/lib/R/site-library/NHPPZISP/stan/NHPP_ZI_LOGISTCOV_09_03_2022.stan")
mod<- stanmodels$NHPP_ZI_LOGISTCOV_23_07_2022
}
}
}
else {
if(ZI==0){
# mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/3.6/spnhppzi/stan/NHPP_COV_FRAT_10.stan")
#
#mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/NHPPZISP/stan/NHPP_COV_FRAT_10.stan")
#mod<- rstan::stan_model("/usr/local/lib/R/site-library/NHPPZISP/stan/NHPP_COV_FRAT_10.stan")
mod <- stanmodels$NHPP_COV_FRAT_10
}
else{
if(q==0){
#mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/3.6/spnhppzi/stan/NHPP_ZI_FRAT_04_07_2022.stan")
#
#mod<- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/NHPPZISP/stan/NHPP_ZI_FRAT_09_03_2022.stan")
# mod<- rstan::stan_model("/usr/local/lib/R/site-library/NHPPZISP/stan/NHPP_ZI_FRAT_09_03_2022.stan")
#mod<- stanmodels$NHPP_ZI_FRAT_09_03_2022
#mod<- rstan::stan_model("/home/alisson/R/x86_64-pc-linux-gnu-library/4.2/spnhppzi/stan/NHPP_ZI_FRAT_04_07_2022.stan")
# mod<- rstan::stan_model("/home/alisson/spnhppzi/inst/stan/NHPP_ZI_FRAT_04_07_2022_1.stan")
mod<- stanmodels$NHPP_ZI_FRAT_04_07_2022
}
else{
#mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/3.6/spnhppzi/stan/NHPP_ZI_LOGISTCOV_FRAT_16_03_2022.stan")
#mod<- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/NHPPZISP/stan/NHPP_ZI_LOGISTCOV_FRAT_16_03_2022.stan")
#mod<- rstan::stan_model("/usr/local/lib/R/site-library/NHPPZISP/stan/NHPP_ZI_LOGISTCOV_FRAT_16_03_2022.stan")
mod<- stanmodels$NHPP_ZI_LOGISTCOV_FRAT_31_07_2022
}
}
}
}
else{
# mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/spnhppzi/stan/SPNHPP_SPARSE_COV_FRAT_10.stan")
mod <- rstan::stan_model("~/R/x86_64-pc-linux-gnu-library/4.2/spnhppzi/stan/SPNHPP_ICAR_COV_FRAT_10.stan")
# mod <- stanmodels$SPNHPP_COV_FRAT_10
}
if(FR==0){
#Optimizing
if(approach==0){
result<- optimizing(stanmodels$mod, data = data_model, hessian =TRUE, init=initial, algorithm = "LBFGS")
return(result)
}
if(approach==1){
#result_b<- sampling(mod, data = data_model, cores = 4, iter=4000)
result_b<- sampling(mod, data = data_model, cores = n_cores, iter=n_iter, chains=n_chains)
# result_b<- sampling(mod, data = data_model, cores = 4, iter=4000,  control = list(max_treedepth = 50,adapt_delta = 0.999))
return(result_b)
}
}
else{
#result_c<- sampling(mod, data = data_model, cores = 4, iter=4000)
result_c<- sampling(mod, data = data_model, cores = n_cores, iter=n_iter,chains=n_chains)
#result_c<- sampling(mod, data = data_model, cores = 4, iter=4000, control = list(max_treedepth = 50,adapt_delta = 0.999))
return(result_c)
}
}
library(spnhppzi)
library(rstan)
library(Formula)
library(dplyr)
library(psych)
library(splitstackshape)
library(sf)
library(mapview)
library(spdep)
library(MASS)
library(matlib)
N<-2000
alpha1_r<-2.0
alpha2_r<-1.3
beta1_r<-0.6
beta2_r<-0.8
sp_tau_r<-1.5
sp_alpha_r<-0.99
pi_r<-0
fu.min<-7
fu.max<-7
# munic_MG<-read_sf('/home/alisson/UFMG/TESE/SIM/MALHAS/MG_Municipios_2021/MG_Municipios_2021.shp')
# shp_munic_MG<-munic_MG$geometry
# plot(shp_munic_MG)
# # View(munic_MG$CD_MUN)
list_RMBH<-c(3165537,3141108,3126000,3140704,3137601,3136652,3132206,3130101,
3129806,3157807,3155306,3154804,3154606,3153905,3124104,3171204,
3168309,3162955,3156700,3133709,3134608,3136603,3140159,3144805,
3106705,3110004,3149309,3105004,3106200,3109006,3112505,3117876,
3118601, 3162922,
#COLAR
3157203, 3126406, 3142304, 3161908, 3108107, 3127206, 3106408, 3147105,
3131901, 3167202, 3153608, 3107703, 3133808, 3163102, 3105400, 3131000
)
length(list_RMBH)
#RMBH<-munic_MG[munic_MG$CD_MUN %in% list_RMBH,]
# plot(RMBH$geometry)
# RMBH$geometry
testeBH<-st_read('/home/alisson/UFMG/TESE/SIM/MALHAS/MG_Municipios_2021/MG_Municipios_2021.shp')
RMBH1<-testeBH[testeBH$CD_MUN %in% list_RMBH,]
dim(RMBH1)
dim(RMBH1)
RMBH_mat <- nb2mat(poly2nb(RMBH1), style = "B")
row.names(RMBH_mat)<-RMBH1$CD_MUN
# mapview(RMBH1)
nrow(RMBH_mat)
View(RMBH_mat)
set.seed(5832)
cov.fu<-spnhppzi::gencovfu(N=N,
fu.min=fu.min,
fu.max=fu.max,
cens.prob = 0,
dist.x = c("binomial","normal"),
par.x=list(0.7, c(0, 1)),
beta.x=c(beta1_r,beta2_r)
)
set.seed(NULL)
base1<-spsimrec2(N=cov.fu$N,
nr.cov=cov.fu$nr.cov,
spatial=1,
list_area=list_RMBH,
SP_N=50,
nb_mat=RMBH_mat,
sp_tau=1.2,
sp_alpha=0.999,
beta.x = cov.fu$beta.x,
x = cov.fu$x,
x1 = cov.fu$x1,
fu = cov.fu$fu,
fu.max = cov.fu$fu.max,
fu.min = cov.fu$fu.min,
dist.z = c("gamma","lognormal"),
random.ef=1,
tp_rnd_ef=0,
par.z=0,
dist.rec="weibull",
par.rec=c(alpha1_r,alpha2_r)
)
table(base1$SP_ID)
dim(as.data.frame(table(base1$SP_ID)))
dim(base1)
base1t<-base1 %>%
group_by(SP_ID) %>%
mutate(SP_ID1=cur_group_id()) %>%
arrange(SP_ID1, ID,rep1)
# View(base1t)
dim(as.data.frame(table(base1t$SP_ID1)))
dim(base1t)
formula2=Formula(spnhppzi::Recur1(end,status,ID,SP_ID1,IndRec)~X1+X2|-1)
RESULT_BAYES_SCOV1<- spnhppzi2(formula2,
base1t,
baseline = "plp1",
FR="TRUE",
ZI="FALSE",
approach = "BAYES",
initial=1,
tp_prior=1,
shp_alpha1=0.1,scl_alpha1=0.1,
shp_alpha2=0.1,scl_alpha2=0.1,
mu_beta=0,sigma_beta=10,
mu_psi=0,sigma_psi=10,
mu_omega=0,
shp_sigma2_z = 0.1, scl_sigma2_z =0.1,
spatial=1,
nb_mat=RMBH_mat,
shp_tau=1,
scl_tau=1,
n_iter = 2000,
n_cores=4,
n_chains=2,
W_n=127
)
pars<- as.data.frame(RESULT_BAYES_SCOV1, pars = c("alpha","beta","tau","sp_alpha"))
pars<- as.data.frame(RESULT_BAYES_SCOV1, pars = c("alpha","beta","tau"))
colnames(pars)<-c("alpha1","alpha2","beta1","beta2","tau","sp_alpha")
colnames(pars)<-c("alpha1","alpha2","beta1","beta2","tau")
# pars<- as.data.frame(RESULT_BAYES_SCOV1, pars = c("alpha","beta","sigma2_z"))
# colnames(pars)<-c("alpha1","alpha2","beta1","beta2","sigma2_z")
pars_desc<-describe(pars,quant=c(.025,.5,.975),fast=TRUE)
pars_desc
rstan:::rstudio_stanc("inst/stan/SPNHPP_SPARSE_COV_FRAT.stan")
remove.packages("spnhppzi")
roxygen2::roxygenize()
remove.packages("spnhppzi")
roxygen2::roxygenize()
